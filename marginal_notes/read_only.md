# К вопросу о неизменности.
*Андрей Гончаров*  
*дн dd месяц YYYY завершения написания*    

*Лишь в неизменном — бесконечность,*  
*Лишь в постоянном глубина.*  
*И дальше путь, и ближе вечность,*  
*И всё ясней: любовь одна.*  

*Зинаида Гиппиус*


##### Аннотация
В статье рассматривается концепция неизменности состояния. На примере языка программирования *C#*, показаны способы выражения и достижения неизменности посредствам различных языковых конструкций. Для каждой языковой конструкции *C#* рассматривается ее результат, в смысле достижения неизменности состояния, и смысловая нагрузка, с точки зрения коммуникотивной функции языка. Предлагается способ обозначения неизменности состояния через выделения из интерфейса класса подможества "только для чтения".    

#### Введение

Сложно переоценить значение концепций переменной и константы в языках программирования. Они на столько важны, что по тому как в языке реализована поддержка этих концепций, языки делят на три большие группы: те в которых нет констант, те в которых нет переменных, и те в которых эти две концепции поддерживаются одновременно. К первой группе, до выхода ECMAScript 2015, относился *javascript*. Вторая группа представлена функциональными языками, например *F#*. Но наиболее распространненной является третья группа, к ней относятся pyhton, C/C++, C#, Java и т.д.

Что такое константность зависит от контектса. Например это может быть просто число *Pi*, а может быть идея о неизменности данных в сообщении, в *Event Driven*[<sup>11</sup>](#11) ситсеме. Но, в конечном итоге, неизменность данных будет выражено некоторыми конструкциями конкретного языка программирования. 

Немного о языках программирования, абстрактно.  

Любой язык программирования, это прежде всего *язык*. Из лингвистике известно[<sup>1</sup>](#1), что одной из функций языка является коммуникативная функция. В контексте языков программироаняи, это выражается в том, что использую различные ключивые слова, конструкции, архитектурные решения, мы передаем некие идеи и мысли тем, кто будет с этим кодом работать дальше. Важно еще и то, что, в большенстве случаев, исходный код - это текст, а текст, в свою очередь, это зафиксированная мысль[<sup>7</sup>](#7). Поэтому выражать свои идеи в коде нужно максимально прозрачным образом. Необходимо стремиться, чтобы количество интерпритаций было минимально. То, что об этом написано уже много литераутры[<sup>8, </sup>](#8)[<sup>9, </sup>](#9)[<sup>10 </sup>](#10), свидетельствует о важности вопрса. Чтобы научится писать хороший код, нужно много времени, и нужны глубокие познания языка на котором пишется программа. Тут важен как поверхностный смысл конструкции, так и то, во что она превращается, т.к. смысл конструкции существенно зависит от реализации на низком уровне. Кроме того, понимание реализации позволяет понять будет ли машина (компилятор/интерпритатор) на нашей стороне в деле защиты данных от попыток их изменить.

Далее, в статье, разбираются основные конструкции языка C#, в плоть до 8-й версии, позволяющие выразить идею незименности данных.  

#### 1. Элементарные конструкции в C# для выражения незименности.
##### Литералы
Первой элементарной конструкцией, выражающей константность, является литерал. Наиболее распространненым случаем использования литералов как константм, является их применение в "условных операторах", например:
```C#
//...
if(x == true) {...}
//...
switch(y) {
    case  "SomeValue":
      //....
...}
//...
```
С моей точки зрения, применения литерала на прямую в "условных операторах" (if/while/for/switch) допустимо только для true/false, литералы других типов надо выносить в именованные константы.   

*Для junior*
```
В языках программирования, где в условных операторах допускается не только булевый тип, 
например в С/С++, компилятор делают 'союзником' меняя местами литерал и переменную:

if("SomveValue" == y ){...}

т.к. ошибочный, по своей сути, код:

if(y = "SomeValue") {...

для компилятора является корректным, в то время как

if("SomeValue" = y) {...
не корректен.
```
##### Ключевое слово const
Для объявления некоторых данных как "константы" в C# есть ключивое слово `const`[<sup>12</sup>](#12).
Это ключивое слово позволяет создавать именованные константы. В С# оно применимо только к элементарным типам, строкам и перечислениям. Фактически, после компиляции, значение сохраненное в константе подставляется в те места где она используется. Т.е. в итоге это идентично использованию литерала.

Ключевое слово `const` можно применить к локальным переменным и к полям класса. В случае полей класса, поля помеченные как `const` по очивидным причинам, являются статическими.
Комбинация применимости `const` к полям класса и тот факт, что после компиляции вхождение константы заменяется на литерал, создает первый пример того, почему надо понимать реализацию на низком уровне. Если вы собрали некоторые константы в некоторый класс своей библиотеки, пометив поля этого класса как `const`, то все вхождения этих констант будут заменены их значениями при компиляции:   
```C#
//----Ваша библиотека, ваш класс констант:
public static class PhysConstants
{ 
    public const double G = 6.674e-11; // m^3 kg^(-1) s^(-2)
    public const double h = 6.626e-34; // J·s
    // и т.д.
}

//---Код клиента до компиляции:
var gF = PhysConstants.G * m1*m2/(r*r);

//---После компиляции, код клиента будет аналогичный следующему:
var gF = 6.674e-11 * m1*m2/(r*r);
```

Если ваша библиотека использовалась где-то еще, любое изменение значение констант в вашей библиотеки, при ее обновлении, будут проигнорированы кодом клиента, если при обновлении не будет выполнена перекомпиляция этого кода[<sup>13</sup>](#13). Чтобы избежать такой ситуации, нужно воспользоваться заменой `const` на комбинацию `static readonly`:
```C#
//----Ваша библиотека, ваш класс констант:
public static class PhysConstants
{ 
    public static readonly double G = 6.674e-11; // m^3 kg^(-1) s^(-2)
    public static readonly double h = 6.626e-34; // J·s
    // и т.д.
}
```

##### Ключевое слово readonly применительно к полям.
Ключивое слово `readonly` имеет несколько способов применения. 
Первое из них то, что описано выше: этим ключевым словом можно помечать поля, которые не должны менять свое значение. Это могут быть поля любих типов. Кроме того, поля помеченные как `readonly` могут быть как статическими, так и не статическими. Смысл ключевого слова `readonly`, применительно к полям, зависимости от типа поля и контекста. Так, если речь идет о статических полях элементарного типа (или строки), то `readonly` можно воспринимать в исходном коде как синоним `const`. Но если речь идет полях - типах-значениях или полях ссылочного типа, то значение `readonly` полностью определяется двумя факторами - внутренним содержанием типа и, опять таки, контекстом. Так, первое что надо понять, это то, что `readonly` гарантирует лишь незименность *значения* помеченного полей, после создания класса (в случае статических полей) / объекта (в случае обычных полей). Под *значением* поля понимается, для ссылочных типов - адрес в куче, для типов значений - объект данного типа. Т.е. `readonly` гарантирует что не будет изменен адрес памяти в куче, в случае ссылочного типа, или, в случае типа-значения, не будет произведена замена объекта. Это единственное что гарантирует `readonly`. Рассматривая контекст, если под константностью подразумивать именно это, то мы имеем константное состояние. Но обычно, под неизменным состоянием понимается распростронение неизменности в глубину. Т.е. неизменной должна быть не только ссылка на объект, хранящаяся в поле `readonly`, но и состояние этого объекта. В таком контексте `readonly` не гарантирует постоянства, здесь в игру вступает внутреннее содержание объекта, на который ссылается поле. Если объект неизменен - то имеется полная неизменность состояния, иначе, состояние может изменяться.  

Другими словами, для понимания имеем ли мы дело с неизменным состоянием или нет, когда сталкиваеся с `readonly`, приходится приложить дополнительные усилия, анализируя код.  
Лично для меня не статическое поле, ссылочного типа, помеченное как `readonly`, говорит лишь о том, что, с вероятностью 99%, это просто поле инициализируемое в конструкторе, не более того. Ни о какой константности речи не идет.

##### Ключевое слово readonly применительно к структурам.
Следующий уровень асбтракции в выражении незименности, являются так называемые иммутабельные объекты[<sup>15</sup>](#15). Иммутабельный объект - это объект, состояние которого задается на момент создания, и не изменяется в течении всего жизненного цикла объекта. К такому типу объектов часто относят объекты-значения[<sup>14</sup>](#14), например в C# это объекты типа DateTime или String. Все операции, которые могли бы привести к изменению состояния, всегда создают новый экземпляр с новым значением. Ниже приведен код деманстрирующий этот факт: 
```C#
var a = new DateTime(2112, 1,21);
var b = a.AddDays(11);
	
Console.WriteLine(Object.ReferenceEquals(a, b)); // -> False
Console.WriteLine(a); // -> 2112-01-21
Console.WriteLine(b); // -> 2012-02-01 

```



[//]: # (литералы, const, readonly static/nonstatic, struct, Шаблон ValueObject, readonly struct, Records, ref struct - оптимизация по памяти, для структур, при возврате. ref readonly - оптимизация по памяти, для структур, при возврате. in param - оптимизация по памяти, для структур, при передаче параметра. - смысловая нагрузка.)

#### 2. Array, ReadOnlyCollection.
[//]: # (Array неверное понимание смысловой нагрузки. IReadOnlyCollection<T>, собственные Readonly - смысловая нагрузка)

#### 3. Метод выделения ReadOnly подможества в API класс
[//]: # (
const в объевлении методов в С++, 
const в объявлении переменных,
конструкция const T& - как оптимизация по памяти, с выражением неизменности.)

#### Заключение
[//]: # (О важности и значимости конструкция указывающих на постоянство.)

##### Список литературы
<a class='anchor' id='1'>1</a>. Мартине А. Основы обшей лингвистики \[в:\] Новое в лингвистике. – М., 1963  
<a class='anchor' id='2'>2</a>. <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">(Wiki) Переменная (программирование)</a>  
<a class='anchor' id='3'>3</a>. <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/const">MDN web docs, const</a>  
<a class='anchor' id='4'>4</a>. <a href="https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">(Wiki) Функциона́льное программи́рование</a>  
<a class='anchor' id='5'>5</a>. <a href="https://ru.wikibooks.org/wiki/Haskell/VariablesAndFunctions#%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B2_%D0%B8%D0%BC%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D1%85_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%D1%85">Haskell/VariablesAndFunctions / Переменные в императивных языках.</a>  
<a class='anchor' id='6'>6</a>. <a href="https://medium.com/@frontman/const-%D0%B2-js-%D0%B4%D0%B5%D0%BB%D0%B0%D0%B5%D1%82-%D1%81%D0%B2%D0%BE%D1%8E-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%83-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE-b346353d9cce">Александр Майоров CONST в JS делает свою работу правильно! Alexander Mayorov — Pro WEB IT</a>  
<a class='anchor' id='7'>7</a>. <a href="https://ru.wikipedia.org/wiki/Текст">(Wiki) Текст</a>  
<a class='anchor' id='8'>8</a>. <a href="https://www.ozon.ru/context/detail/id/142768363/">Макконнелл С. Совершенный код. Мастер-класс / БХВ-Петербург, 2017</a>  
<a class='anchor' id='9'>9</a>. <a href="https://www.ozon.ru/context/detail/id/4187085/">Идеальный код / Под ред. Энди Орам, Грегори Уилсон. – Питер, 2009.</a>  
<a class='anchor' id='10'>10</a>. <a href="https://www.ozon.ru/context/detail/id/4187085/">Мартин Фаулер, Кент Бек, Джон Брант, Дон Робертс Рефакторинг. Улучшение проекта существующего кода / Вильямс, 2017.</a>  
<a class='anchor' id='11'>11</a>. <a href="https://youtu.be/vSd_0zGxsIU">Allard Buijze Pragmatic Event-Driven Microservices / GOTO 2018</a>   
<a class='anchor' id='12'>12</a>. <a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/const">const / MSDN</a>   
<a class='anchor' id='13'>13</a>. <a href="https://www.ozon.ru/context/detail/id/140145915/">Билл Вагнер Эффективное программирование на C#. 50 способов улучшения кода / Вильямс, 2017.</a>   
<a class='anchor' id='14'>14</a>. <a href="https://www.ozon.ru/context/detail/id/147107976/">Эрик Эванс Предметно-ориентированное проектирование (DDD). Структуризация сложных программных систем / Вильямс, 2018.</a>   
<a class='anchor' id='15'>15</a>. <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D0%B9_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82">(Wiki) Неизменяемый объект</a> 


